 {*tocheck[i][3]: i in [1..#tocheck]*};  

{* 512^^4, 594, 640^^14, 768^^36, 960^^64, 1152^^28, 1536^^6, 1920^^17, 1944^^5,
2016^^15, 2040, 2080^^2, 2088, 2100, 2112^^2, 2160^^22, 2184^^5, 2208, 2240, 
2268^^2, 2304^^7, 2400^^8, 2448^^2, 2496^^3, 2520^^28, 2592^^4, 2688^^7, 2700, 
2800, 2808^^4, 2880^^7, 3000^^3, 3024^^4, 3072, 3120^^4, 3150, 3240^^3, 3360^^4,
3456, 3600^^6, 3744^^4, 3840^^3, 3888, 4032^^2, 4200, 4212^^2, 4320^^3, 4536, 
4800, 4860, 5040^^6, 5200^^2, 5360, 5376, 5400, 5600, 5616^^2, 5760, 6000, 
6048^^2, 6240^^2, 6480, 6720, 7200, 7488^^2, 7560^^3, 7680, 7776, 8064, 8352, 
8640, 9828^^2, 10080, 15120 *}

// No one of the groups of the list can be perfect: 

time how_to_excludePG(tocheck);

[* *]
Time: 85.710

// Let us exclude those triples having group order {512,594,640,960,1152,1920};

time Result:=how_to_exclude(tocheck: Interested_orders:={512,594,640,960,1152,1920}); 

Time: 11024.750

Result;
[* *]

time Result:=how_to_exclude(tocheck: Interested_orders:={1944});

Time: 145.680

#Result;
4

ExistingSurfaces(Result);
[* [*
    {* 1/4, 1/2^^2, 3/4 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    <1944, 3875>
*] *]

time Result:=how_to_exclude(tocheck: Interested_orders:={768});

Time: 39400.880
#Result;
4

ExistingSurfaces(Result);
[* *]


// We now exclude the six cases of group order 1536. These cases are the following:

[*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    1536
*],
[*
    {* 1/4^^4 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 64 *}
    *},
    1536
*],
[*
    {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 6, 8 *}
    *},
    1536
*],
[*
    {* 1/3^^2, 2/3^^2 *},      
    {*
        {* 2, 3, 12 *},
        {* 2, 3, 16 *} 
    *},
    1536
*],
[*
    {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 24 *}
    *},
    1536
*],
[*
    {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 16 *},
        {* 2, 4, 6 *}
    *},
    1536
*]

// However, from Proposition 3.3 of "The classification of minimal product-quotient surfaces with pg=0" by Bauer-Pignatelli, there is only one group of order 1536 admitting an appropriate spherical system of generators of signature {2,3,8} having abelianization of order 2. This group is <1536, 408544637>. Let us consider 

Result:=[*[*
 {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    <1536, 408544637>
*],
[*
 {* 1/4^^4 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 64 *}
    *},
    <1536, 408544637>
*],
[*
 {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 6, 8 *}
    *},
    <1536, 408544637>
*],
[*
 {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 24 *}
    *},
    <1536, 408544637>
*]
*];

ExistingSurfaces(Result);
[* *]

// Now we have to check the remaining two cases

tocheck_1536:=[*[*
    {* 1/3^^2, 2/3^^2 *},      
    {*
        {* 2, 3, 12 *},
        {* 2, 3, 16 *} 
    *},
    1536
*]*];

time Result:=how_to_exclude(tocheck_1536);

Time: 164603.400
Result;
[* *]

tocheck_1536:=[*[*
    {* 1/3^^2, 2/3^^2 *},
    {*
        {* 2, 3, 16 *},
        {* 2, 4, 6 *}
    *},
    1536
*]*];

time Result:=how_to_exclude(tocheck_1536);

Time: 161794.940
Result;
[* *]


// In this way we have excluded all groups of tocheck less or equal than 2000. 

////////////////////////////////////////////////////////////

List:=[*x : x in tocheck | x[3] gt 2000*];

Result, NotSatisfyProp33, PerfectGroups:=List_Intermediate_Sign(List);

#Result;
189
> #NotSatisfyProp33;
4
> #PerfectGroups;
68

// Since we have already excluded that no one of the groups of tocheck is perfect, then we can automatically exclude the triples stored in PerfectGroups;

{* x[3]: x in Result*};
{* 672^^3, 696, 720^^4, 756^^2, 900, 936^^4, 960^^2, 1008^^19, 1020, 1040^^6, 
1050, 1056^^2, 1080^^15, 1104, 1120^^3, 1152^^7, 1200^^14, 1224, 1248^^7, 
1260^^6, 1296^^6, 1344^^3, 1400, 1404^^2, 1440^^8, 1500, 1512^^3, 1536, 1560^^8,
1575, 1620^^2, 1680^^6, 1728, 1800^^4, 1872^^8, 1920^^4, 1944, 2016^^4, 2100, 
2160^^4, 2400, 2520, 2600^^2, 2680, 2700, 2800, 3000, 3120^^2, 3240, 3360, 3600,
3744^^2, 3840, 3888, 4032, 4176, 4320 *}


time Res,ResAb:=how_to_exclude(Result: Interested_orders:={ j : j in [1..2000] | j ne 1536});

Time: 1815.640

#Res;
20

{*x[1]: x in Res*};
{*
    {* 1/4, 1/2^^2, 3/4 *}^^2,
    {* 1/4^^2, 1/2^^3 *}^^2,
    {* 1/4^^4 *}^^11,
    {* 1/3^^2, 2/3^^2 *}^^5
*}


IntBasket:=function(a, j)
  IntB:=[];
  B:={k/a : k in [1..a-1]};
  for i in [0..j] do 
    Append(~IntB, Multisets(B, i));
  end for;
  Fin:={};
  for i in [1..#IntB] do 
    for s in IntB[i] do 
      Include(~Fin, s);
    end for;
  end for;
  return Fin;
end function;

FinIntBasket:=function(basket)
  Final:=[**];

  t:={* Denominator(r): r in basket*};
  Seq:=[[a,#[ x : x in t | x eq a]]: a in MultisetToSet(t)];
  A:=[];
  for s in Seq do 
     Append(~A, IntBasket(s[1],s[2]));
  end for;  
  for x in CartesianProduct(A) do  
   int_bas:={**};
   for l in x do 
    for y in l do 
      Include(~int_bas, y); 
    end for;
   end for;
   Append(~Final, int_bas);
  end for; 
  return {x : x in Final};
end function;

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExSurf:=ExistingSurfaces(FinRes);
Time: 248.970

ExSurf;
[* [*
    {* 1/2^^2 *},
    {*
        {* 3^^2, 4 *},
        {* 3^^2, 6 *}
    *},
    <1944, 3875>
*] *]

// This came from 

tocheck[264];

[*
    {* 1/4, 1/2^^2, 3/4 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 3, 12 *}
    *},
    3888
*]

// From Prop. 3.3 and Remark 3.10(1) of our paper, we have that a group of order 3888 satisfying the required algebraic data should be a semidirect product of the groups H obtained in ExSurf and a cyclic group of order 2 by an automorphism phi of order 2.

Final:=[**];
tocheck_compatible3888:=[**];

K:=SmallGroup(2,1);

for x in ExSurf do 
  H:=SmallGroup(x[3][1],x[3][2]);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord2:={phi: phi in P| Order(phi) eq 2}; {*Order(phi): phi in P*};
  for phi in ord2 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <2,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*2,3,8*}) then 
            if ExSphSystem_givenG(G,{*2,3,12*}) then 
             Append(~tocheck_compatible3888,[*{* 1/4, 1/2^^2, 3/4 *},{*{*2,3,8*},{*2,3,12*}*},G*]); 
           
           end if;
           end if; 
    end if;
    
  end for;
end for; 

tocheck_compatible3888;
[* *]

// Now we have to exclude the last case of Result with group order less or equal than 2000

Cases_1536:=[* x: x in Result | x[3] eq 1536*];

Cases_1536;
[* [*
    {* 1/3^^2, 2/3^^2 *},
    {*
        {* 3^^2, 4 *},
        {* 3^^2, 8 *}
    *},
    1536
*] *]

time Res_2:=how_to_exclude(Cases_1536);
Time: 164357.480

Res_2;
[* *];



Result_group_gt_2000:=[* x : x in Result | x[3] gt 2000*];

time how_to_excludePG(Result_group_gt_2000);

[* *]
Time: 5.820

Result_2, NotSatisfyProp33_2, PerfectGroups_2:=List_Intermediate_Sign(Result_group_gt_2000);

#Result_2;
23
> #NotSatisfyProp33_2;
0
> #PerfectGroups_2;
10

{* x[3]: x in Result_2*};
{* 520^^2, 536, 540, 560, 600, 672^^4, 720^^4, 800, 840, 1248^^2, 1280, 1296, 
1344, 1392, 1440 *}

time Res_2,ResAb_2:=how_to_exclude(Result_2);

Time: 5260.660

#Res_2;
82

IntBasket:=function(a, j)
  IntB:=[];
  B:={k/a : k in [1..a-1]};
  for i in [0..j] do 
    Append(~IntB, Multisets(B, i));
  end for;
  Fin:={};
  for i in [1..#IntB] do 
    for s in IntB[i] do 
      Include(~Fin, s);
    end for;
  end for;
  return Fin;
end function;

FinIntBasket:=function(basket)
  Final:=[**];

  t:={* Denominator(r): r in basket*};
  Seq:=[[a,#[ x : x in t | x eq a]]: a in MultisetToSet(t)];
  A:=[];
  for s in Seq do 
     Append(~A, IntBasket(s[1],s[2]));
  end for;  
  for x in CartesianProduct(A) do  
   int_bas:={**};
   for l in x do 
    for y in l do 
      Include(~int_bas, y); 
    end for;
   end for;
   Append(~Final, int_bas);
  end for; 
  return {x : x in Final};
end function;

FinRes_2:=[**];

for x in Res_2 do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes_2, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExSurf:=ExistingSurfaces(FinRes_2);

Time: 4689.220
ExSurf;
[* *]


// In this way we have excluded all the cases of Result list. Now we have to exclude the last two cases stored in NotSatisfyProp33

NotSatisfyProp33;
[* [*
    {* 1/4^^2, 1/2^^3 *},
    {*  
        {* 2, 3, 12 *}^^2
    *},
    2016
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*  
        {* 2, 4, 6 *}^^2
    *},
    2016
*], [*
    {* 1/4^^4 *},
    {*  
        {* 2, 3, 12 *}^^2
    *},
    2160
*], [*
    {* 1/4^^4 *},
    {*  
        {* 2, 4, 6 *}^^2
    *},
    2160
*] *]

time how_to_excludePG(NotSatisfyProp33);
[* *]
Time: 0.450

// The abelianization of the orbifold group of signature {* 2, 3, 12 *} is C6, hence the abelianization of G may be at most either C2, C3, or C6. If the abelianization if C6, then it there exists a normal subgroup of G with index 2, the inverse image of a index 2 subgroup of C6 by the abelianization map of G. 


List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[1],2);
[* [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 3^^2, 6 *}^^2
    *},
    1008
*] *]
List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[1],3);
[* [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2^^3, 4 *}^^2
    *},
    672
*] *]

L:=[*
[*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 3^^2, 6 *}^^2
    *},
    1008
*],
[*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2^^3, 4 *}^^2
    *},
    672
*] *];

time Res,Res_Ab:=how_to_exclude(L);
Time: 3.320

#Res;
7

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

ExistingSurfaces(FinRes);
[* *]

// We have excluded NotSatisfyProp33[1];

// We exclude NotSatisfyProp33[2], whose orbifold group has abelianization C2^2. Hence G has abelianization either C2 or C2^2. However 

L:=List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[2],2);

 L;
[* [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2^^3, 3 *},
        {* 3, 4^^2 *}
    *},
    1008
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2, 6^^2 *},
        {* 3, 4^^2 *}
    *},
    1008
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2, 6^^2 *}^^2
    *},
    1008
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2, 6^^2 *},
        {* 2^^3, 3 *}
    *},
    1008
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 2^^3, 3 *}^^2
    *},
    1008
*], [*
    {* 1/4^^2, 1/2^^3 *},
    {*
        {* 3, 4^^2 *}^^2
    *},
    1008
*] *]



time Res,Res_Ab:=how_to_exclude(L);

Time: 168.060
 
#Res; 
6

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

ExistingSurfaces(FinRes);                                      
[* *]

List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[3],2);
[* [*
    {* 1/4^^4 *},
    {*
        {* 3^^2, 6 *}^^2
    *},
    1080
*] *]
List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[3],3);
[* [*
    {* 1/4^^4 *},
    {*
        {* 2^^3, 4 *}^^2
    *},
    720
*] *]

L:=[*
[*
    {* 1/4^^4 *},
    {*
        {* 3^^2, 6 *}^^2
    *},
    1080
*],
[*
    {* 1/4^^4 *},
    {*
        {* 2^^3, 4 *}^^2
    *},
    720
*]*];

time Res,Res_Ab:=how_to_exclude(L);
Time: 6.020
#Res; 
10

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

ExistingSurfaces(FinRes);
[* *]

L:=List_Intermediate_Sign_from_a_triple(NotSatisfyProp33[4],2);


L;
[* [*
    {* 1/4^^4 *},
    {*
        {* 2^^3, 3 *},
        {* 3, 4^^2 *}
    *},
    1080
*], [*
    {* 1/4^^4 *},
    {*
        {* 2, 6^^2 *},
        {* 3, 4^^2 *}
    *},
    1080
*], [*
    {* 1/4^^4 *},
    {*
        {* 2, 6^^2 *}^^2
    *},
    1080
*], [*
    {* 1/4^^4 *},
    {*
        {* 2, 6^^2 *},
        {* 2^^3, 3 *}
    *},
    1080
*], [*
    {* 1/4^^4 *},
    {*
        {* 2^^3, 3 *}^^2
    *},
    1080
*], [*
    {* 1/4^^4 *},
    {*
        {* 3, 4^^2 *}^^2
    *},
    1080
*] *]

time Res,Res_Ab:=how_to_exclude(L);
Time: 509.030

Res;
[* *]


// We have excluded all the cases stored in the secondary output of ListGroups(26,4);