 {*tocheck[i][3]: i in [1..#tocheck]*};  

{* 512^^9, 594^^2, 640^^44, 768^^93, 960^^195, 1152^^88, 1536^^12, 1920^^39, 
1944^^17, 2016^^39, 2040^^4, 2052^^3, 2064, 2080^^9, 2100, 2112^^16, 2160^^58, 
2184^^23, 2208^^4, 2240^^5, 2268^^2, 2304^^18, 2352, 2376^^4, 2400^^14, 
2448^^30, 2496^^11, 2520^^67, 2592^^19, 2640^^3, 2664^^2, 2688^^18, 2700^^2, 
2720^^4, 2790, 2808^^14, 2880^^17, 2940, 2970, 3000^^4, 3024^^12, 3072, 
3120^^14, 3150^^2, 3168^^6, 3240^^3, 3264^^4, 3300, 3360^^5, 3456^^4, 3552^^2, 
3600^^8, 3672^^6, 3720, 3744^^14, 3840^^5, 3888^^5, 3960, 3996, 4032^^4, 
4080^^12, 4200^^2, 4212^^7, 4224^^2, 4320^^3, 4416, 4536^^2, 4752, 4800^^4, 
4896^^9, 4960, 4968, 5000, 5040^^16, 5120, 5200^^7, 5280^^2, 5360, 5376, 
5400^^4, 5508^^3, 5600^^2, 5616^^7, 5760^^3, 6000, 6048^^8, 6240^^7, 6480^^3, 
6720^^2, 6800^^3, 6912^^2, 7104, 7200^^3, 7488^^7, 7560^^2, 7584, 7680, 7776^^3,
8064^^2, 8160^^3, 8448, 8496, 8832, 9072, 9504^^3, 9600, 9792^^3, 9828^^7, 
10080^^3 *}

// No one of the groups of the list can be perfect: 

time Result:=how_to_excludePG(tocheck);

Time: 351.310

#Result;
10

PG:=PerfectGroupDatabase();
for x in Result do 
  G:=PermutationGroup(PG,x[3][1],x[3][2]);
  Triple:=[*x[1],x[2], G*];
  if ExistingSurfaces_triple_givenG(Triple) then x; end if; 
end for; 


// Hence no cases of PerfectGroups occur. 

// Let us exclude those triples having group order {512,594,640,960,1152,1920};

time Result:=how_to_exclude(tocheck: Interested_orders:={512,594,640,960,1152,1920}); 

Time: 24678.430

Result;
[* *]

 Result;
[* [*
    {* 2/5^^4 *},
    {*
        {* 2, 4, 5 *},
        {* 2, 5, 6 *}
    *},
    <1920, 240996>
*], [*
    {* 2/5^^4 *},
    {*
        {* 2, 5, 6 *},
        {* 2, 5^^2 *}
    *},
    <960, 11358>
*] *]

ExistingSurfaces(Result);
[* *]

time Result:=how_to_exclude(tocheck: Interested_orders:={1944});
Time: 438.770

#Result;
12

ExistingSurfaces(Result);
[* *]

time Result:=how_to_exclude(tocheck: Interested_orders:={768});

Time: 101368.210

#Result;
7

ExistingSurfaces(Result);                                      
[* [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 4, 6 *},
        {* 2, 6, 8 *}
    *},
    <768, 1086051>
*] *]


// We now exclude the cases of group order 1536. These cases are the following

[*x : x in tocheck | x[3] eq 1536*];
[* [*
    {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 48 *}
    *},
    1536
*], [*
    {* 1/4^^4, 1/2^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    1536
*], [*
    {* 1/2^^8 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 16 *}
    *},
    1536
*], [*
    {* 1/6, 2/9, 5/18 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 96 *}
    *},
    1536
*], [*
    {* 1/12, 5/12, 1/2 *},
    {*
        {* 2, 3, 16 *}^^2
    *},
    1536
*], [*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 256 *}
    *},
    1536
*], [*
    {* 1/2^^3, 3/4^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 16 *}
    *},
    1536
*], [*
    {* 1/6, 1/3^^4, 1/2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    1536
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 6, 8 *}
    *},
    1536
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 12 *},
        {* 2, 3, 16 *}
    *},
    1536
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 24 *}
    *},
    1536
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 16 *},
        {* 2, 4, 6 *}
    *},
    1536
*] *]

// However, from Proposition 3.3 of "The classification of minimal product-quotient surfaces with pg=0" by Bauer-Pignatelli, there is only one group of order 1536 admitting an appropriate spherical system of generators of signature {2,3,8} having abelianization of order 2. This group is <1536, 408544637>. Let us consider 

Result:=[*[*
    {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 48 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/4^^4, 1/2^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/2^^8 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 16 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/6, 2/9, 5/18 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 96 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 256 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/2^^3, 3/4^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 16 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/6, 1/3^^4, 1/2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 32 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 6, 8 *}
    *},
    <1536, 408544637>
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 4, 24 *}
    *},
    <1536, 408544637>
*]*];

ExistingSurfaces(Result);
[* *]

It remains to discuss only three cases: 

L:=[*[*
    {* 1/12, 5/12, 1/2 *},
    {*
        {* 2, 3, 16 *}^^2
    *},
    1536
*]*];

time Result:=how_to_exclude(L); 
Time: 157316.120

Result;
[* [*
    {* 1/12, 5/12, 1/2 *},
    {*  
        {* 2, 3, 16 *}^^2
    *},
    <1536, 408544627>
*], [*
    {* 1/12, 5/12, 1/2 *},
    {*  
        {* 2, 3, 16 *}^^2
    *},
    <1536, 408544629>
*], [*
    {* 1/12, 5/12, 1/2 *},
    {*  
        {* 2, 3, 16 *}^^2
    *},
    <1536, 408544631>
*], [*
    {* 1/12, 5/12, 1/2 *},
    {*  
        {* 2, 3, 16 *}^^2
    *},
    <1536, 408544634>
*] *]

ExistingSurfaces(Result);
[* *]

// The remaining two cases can be discussed together

L:=[*[*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 12 *},
        {* 2, 3, 16 *}
    *},
    1536
*], [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 16 *},
        {* 2, 4, 6 *}
    *},
    1536
*]*];

// These can be automatically excluded since the same computation is already done in the case (Ksquare, chi)=(26,4). More precisely, It turns out that there are not groups of order 1536 having a pair of spherical systems of generators compatible with the signatures {* 2, 3, 12 *} and {* 2, 3, 16 *}, and with the signatures {* 2, 3, 16 *}, {* 2, 4, 6 *}. 


// In this way we have excluded all groups of tocheck less or equal than 2000. 

////////////////////////////////////////////////////////////

List:=[*x : x in tocheck | x[3] gt 2000*];

Result, NotSatisfyProp33, PerfectGroups:=List_Intermediate_Sign(List);

 #Result;
639
> #NotSatisfyProp33;
14
> #PerfectGroups;
182


// Since we have already excluded that no one of the groups of tocheck is perfect, then we can automatically exclude the triples stored in PerfectGroups;

{* x[3]: x in Result*};
{* 672^^6, 684^^3, 704^^2, 720^^4, 756^^2, 792^^4, 816^^7, 840, 864^^4, 888^^2, 
936^^14, 960^^2, 1008^^45, 1020^^4, 1032, 1040^^23, 1050, 1056^^25, 1080^^40, 
1104^^3, 1120^^9, 1152^^22, 1176, 1200^^17, 1224^^19, 1248^^25, 1260^^15, 
1296^^23, 1320^^5, 1332, 1344^^11, 1350^^2, 1360^^10, 1395, 1404^^7, 1440^^20, 
1470, 1485, 1500^^5, 1512^^10, 1536, 1560^^28, 1575^^2, 1584^^5, 1620^^3, 
1632^^10, 1650, 1656, 1680^^9, 1728^^8, 1776^^4, 1800^^7, 1836^^3, 1860, 
1872^^28, 1920^^6, 1944^^3, 1980, 2016^^8, 2040^^12, 2100^^2, 2112^^4, 2160^^2, 
2208^^3, 2400^^6, 2448^^12, 2480, 2500, 2520^^2, 2560, 2600^^7, 2640^^2, 2680, 
2700^^3, 2800^^2, 2880^^2, 3000, 3120^^7, 3240^^3, 3360^^2, 3400^^3, 3456^^2, 
3552, 3600^^2, 3744^^7, 3792, 3840, 3888^^3, 4032^^2, 4080^^3, 4224, 4248, 4416,
4536, 4752^^3, 4800, 4896^^3 *}

time Res,ResAb:=how_to_exclude(Result: Interested_orders:={x[3] : x in Result| x[3] le 2000 and x[3] ne 1536 and x[3] ne 1836});

Time: 5867.590

#Res;
35

IntBasket:=function(a, j)
  IntB:=[];
  B:={k/a : k in [1..a-1]};
  for i in [0..j] do 
    Append(~IntB, Multisets(B, i));
  end for;
  Fin:={};
  for i in [1..#IntB] do 
    for s in IntB[i] do 
      Include(~Fin, s);
    end for;
  end for;
  return Fin;
end function;

FinIntBasket:=function(basket)
  Final:=[**];

  t:={* Denominator(r): r in basket*};
  Seq:=[[a,#[ x : x in t | x eq a]]: a in MultisetToSet(t)];
  A:=[];
  for s in Seq do 
     Append(~A, IntBasket(s[1],s[2]));
  end for;  
  for x in CartesianProduct(A) do  
   int_bas:={**};
   for l in x do 
    for y in l do 
      Include(~int_bas, y); 
    end for;
   end for;
   Append(~Final, int_bas);
  end for; 
  return {x : x in Final};
end function;

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExistingSurfaces(FinRes);
[* [*
    {* 1/2^^2 *},
    {*  
        {* 3^^2, 4 *},
        {* 3^^2, 6 *}
    *},
    <1944, 3875>
*], [*
    {* 1/2^^2 *},
    {*  
        {* 3^^2, 4 *},
        {* 3^^2, 6 *}
    *},
    <1944, 3875>
*], [*
    {* 1/2^^2 *},
    {*  
        {* 3^^2, 4 *},
        {* 3^^2, 6 *}
    *},
    <1944, 3875>
*] *]
Time: 3722.460

// This intermediate quotient comes from one among 

[* [*
    {* 1/4, 1/3^^2, 1/2, 7/12 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 3, 12 *}
    *},
    3888
*], [*
    {* 1/4, 3/8^^2, 1/2^^2 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 3, 12 *}
    *},
    3888
*], [*
    {* 1/4^^3, 1/2, 3/4 *},
    {*
        {* 2, 3, 8 *},
        {* 2, 3, 12 *}
    *},
    3888
*]

// From Prop. 3.3 and Remark 3.10(1) of our paper, we have that a group of order 3888 satisfying the required algebraic data should be a semidirect product of the group H=<1944, 3875>  and a cyclic group of order 2 by an automorphism phi of order 2.

Final:=[**];
tocheck_compatible3888:=[**];

K:=SmallGroup(2,1);

  H:=SmallGroup(1944,3875);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord2:={phi: phi in P| Order(phi) eq 2}; {*Order(phi): phi in P*};
  for phi in ord2 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* H, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <2,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*2,3,8*}) then 
            if ExSphSystem_givenG(G,{*2,3,12*}) then 
             Append(~tocheck_compatible3888,[*{* 1/4, 1/3^^2, 1/2, 7/12 *},{*{*2,3,8*},{*2,3,12*}*},G*]); 
             Append(~tocheck_compatible3888,[*{* 1/4, 3/8^^2, 1/2^^2 *},{*{*2,3,8*},{*2,3,12*}*},G*]);
             Append(~tocheck_compatible3888,[*{* 1/4^^3, 1/2, 3/4 *},{*{*2,3,8*},{*2,3,12*}*},G*]); 
           
           end if;
           end if; 
    end if;
    
  end for;

tocheck_compatible3888;
[* *]

// This ends the exclusion of the Res cases

// Now let us consider those groups of Result of order equal to 1836

[* x : x in Result |x[3] eq 1836*];                  
[* [*
    {* 1/8^^2, 1/4, 1/2 *},
    {*
        {* 2^^3, 3 *}^^2
    *},
    1836
*], [*
    {* 1/10, 1/5^^2, 1/2 *},
    {*
        {* 2^^3, 3 *}^^2
    *},
    1836
*], [*
    {* 1/12, 1/4, 1/3^^2 *},
    {*
        {* 2^^3, 3 *}^^2
    *},
    1836
*] *]

time Res,ResAb:=how_to_exclude(Result: Interested_orders:={1836});

// This does not finish, so we have to use another technique. The cases of List having as intermediate quotient a group of order 1836 are the following 

[*
    {* 1/8^^2, 1/4, 1/2 *},
    {*
        {* 2, 3, 9 *}^^2
    *},
    5508
*],
[*
    {* 1/10, 1/5^^2, 1/2 *},
    {*
        {* 2, 3, 9 *}^^2
    *},
    5508
*],
[*
    {* 1/12, 1/4, 1/3^^2 *},
    {*
        {* 2, 3, 9 *}^^2
    *},
    5508
*] 

// From Prop. 3.3 and Remark 3.10(1) of our paper, we have that a group of order 5508 satisfying the required algebraic data should be a semidirect product of a group H of order 1836  and a cyclic group of order 3 by an automorphism phi of order 3.

Final:=[**];
tocheck_compatible5508:=[**];

K:=SmallGroup(3,1);

for i in [1..NumberOfSmallGroups(1836)] do 
 for x in [* y : y in Result |y[3] eq 1836*] do 

H:=SmallGroup(x[3],i);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord3:={phi: phi in P| Order(phi) eq 3}; {*Order(phi): phi in P*};
  for phi in ord3 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <3,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{* 2, 3, 9 *}) then 
             Append(~tocheck_compatible5508,[*x[1],{*{* 2, 3, 9 *}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;
end for;

tocheck_compatible5508;
[* *]

// It remains to only discuss the case of Result with group order 1536

[* i : i in [1..#Result]| Result[i][3] eq 1536*];
[* 490 *]

Result[490];
[* [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 3^^2, 4 *},
        {* 3^^2, 8 *}
    *},
    1536
*] *]

time Res,ResAb:=how_to_exclude(Result: Interested_orders:={1536});
Time: 167884.640

Res;
[* *]

Result_group_gt_2000:=[* x : x in Result | x[3] gt 2000*];

time ResultPG:=how_to_excludePG(Result_group_gt_2000);

Time: 50.460

PG:=PerfectGroupDatabase();
for x in ResultPG do 
  G:=PermutationGroup(PG,x[3][1],x[3][2]);
  Triple:=[*x[1],x[2], G*];
  if ExistingSurfaces_triple_givenG(Triple) then x; end if; 
end for; 
>

// Hence no cases of PerfectGroups occur. 

Result_2, NotSatisfyProp33_2, PerfectGroups_2:=List_Intermediate_Sign(Result_group_gt_2000);

 #Result_2;
84
> #NotSatisfyProp33_2;
0
> #PerfectGroups_2;
48

{* x[3]: x in Result_2*};
{* 480^^2, 496, 500, 512, 520^^7, 528, 536, 540^^3, 560^^2, 672^^8, 680^^3, 704^^4, 720^^2, 736, 800^^2, 816^^12, 840^^2, 880, 1152^^2, 1184, 1200^^2, 1248^^7, 1264, 1280, 1296^^3, 1344^^2, 1408, 1416, 1472, 1512, 1584^^3, 1600, 1632^^3 *}

time Res_2,ResAb_2:=how_to_exclude(Result_2: Interested_orders:={ j : j in [1..2000] | j ne 512 and j ne 1264 and j ne 1416});

Time: 15221.020

#Res_2;
261

IntBasket:=function(a, j)
  IntB:=[];
  B:={k/a : k in [1..a-1]};
  for i in [0..j] do 
    Append(~IntB, Multisets(B, i));
  end for;
  Fin:={};
  for i in [1..#IntB] do 
    for s in IntB[i] do 
      Include(~Fin, s);
    end for;
  end for;
  return Fin;
end function;

FinIntBasket:=function(basket)
  Final:=[**];

  t:={* Denominator(r): r in basket*};
  Seq:=[[a,#[ x : x in t | x eq a]]: a in MultisetToSet(t)];
  A:=[];
  for s in Seq do 
     Append(~A, IntBasket(s[1],s[2]));
  end for;  
  for x in CartesianProduct(A) do  
   int_bas:={**};
   for l in x do 
    for y in l do 
      Include(~int_bas, y); 
    end for;
   end for;
   Append(~Final, int_bas);
  end for; 
  return {x : x in Final};
end function;

FinRes_2:=[**];

for x in Res_2 do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes_2, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExSurf:=ExistingSurfaces(FinRes_2);

Time: 66126.640

ExSurf;
[* [*
    {* *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 5232>
*], [*
    {* 1/2^^8 *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 6619>
*], [*
    {* 1/2^^8 *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 868>
*], [*
    {* *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 1167>
*], [*
    {* 1/2^^8 *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 1167>
*], [*
    {* *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 1167>
*], [*
    {* *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 5232>
*] *]

// The groups of order 1152 come from the following triples of Result:

 [* x : x in Result| x[3] eq 3456*];
[* [*
    {* 1/2^^8 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    3456
*], [*
    {* 1/2^^3, 3/4^^2 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    3456
*] *]

T:=[*[*
    {* *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 5232>
*], [*
    {* 1/2^^8 *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 6619>
*]*];

Final:=[**];
tocheck_compatible3456:=[**];

K:=SmallGroup(3,1);

for x in T do 
  H:=SmallGroup(x[3][1],x[3][2]);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord3:={phi: phi in P| Order(phi) eq 3}; {*Order(phi): phi in P*};
  for phi in ord3 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <3,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*3,3,4*}) then 
             Append(~tocheck_compatible3456,[*{* 1/2^^8 *},{*{*3,3,4*}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;

#tocheck_compatible3456;
1152

ExSurf3456:=[**];

for x in tocheck_compatible3456 do 
       IdentifyGroup(quo<x[3]|DerivedGroup(x[3])>); // DEBUG
       if ExistingSurfaces_triple_givenG(x) then  
            Append(~ExSurf3456, x);
          end if; 
end for;

ExSurf3456;         
[* *]

T:=[*[*
    {* *},
    {*  
        {* 4^^3 *}^^2
    *},
    <1152, 5232>
*]*];

Final:=[**];
tocheck_compatible3456:=[**];

K:=SmallGroup(3,1);

for x in T do 
  H:=SmallGroup(x[3][1],x[3][2]);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord3:={phi: phi in P| Order(phi) eq 3}; {*Order(phi): phi in P*};
  for phi in ord3 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <3,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*3,3,4*}) then 
             Append(~tocheck_compatible3456,[*{* 1/2^^3, 3/4^^2 *},{*{*3,3,4*}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;

ExSurf3456:=[**];

for x in tocheck_compatible3456 do 
       IdentifyGroup(quo<x[3]|DerivedGroup(x[3])>); // DEBUG
       if ExistingSurfaces_triple_givenG(x) then  
            Append(~ExSurf3456, x);
          end if; 
end for;

ExSurf3456;                                                                  
[* *]  

// The groups of order 480 come from the following triples of Result:

 [*
    {* 1/2^^8 *},
    {*
        {* 2, 5^^2 *}^^2
    *},
    2400
*],
[*
    {* 1/2^^3, 3/4^^2 *},
    {*
        {* 2, 5^^2 *}^^2
    *},
    2400
*]

T:=[*
[*
    {* 1/2^^8 *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 1167>
*], [*
    {* *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 1167>
*],
[*
    {* 1/2^^8 *},
    {*  
        {* 2^^5 *}^^2
    *},
    <480, 868>
*]
*];

Final:=[**];
tocheck_compatible2400:=[**];

K:=SmallGroup(5,1);

for x in T do 
  H:=SmallGroup(x[3][1],x[3][2]);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord5:={phi: phi in P| Order(phi) eq 5}; {*Order(phi): phi in P*};
  for phi in ord5 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <5,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*2,5,5*}) then 
             Append(~tocheck_compatible2400,[*{* 1/2^^8 *},{*{*2,5,5*}^^2*},G*]); 
             Append(~tocheck_compatible2400,[*{* 1/2^^3, 3/4^^2 *},{*{*2,5,5*}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;

tocheck_compatible2400;
[* *]

// Now we discuss those triples of Result_2 that have group order 512, 1264, 1416 excluded before. 

[* x: x in Result_2| x[3] eq 512*];
[* [*
    {* 2/5^^4 *},
    {*
        {* 2^^5 *}^^2
    *},
    512
*] *]

// This comes from a group of order 2560 in Result:

 [* x : x in Result | x[3] eq 2560*];
[* [*
    {* 2/5^^4 *},
    {*
        {* 2, 5^^2 *}^^2
    *},
    2560
*] *]

time Res_2,ResAb_2:=how_to_exclude(Result_2: Interested_orders:={512});
// This function requires too much time to be processed and a lot of memory usage. For this reason, we have studied separately which groups of order 512 admit a spherical system of generators of signature [2,2,2,2,2]. It returns that there are exactly 701 groups like this, and we stored them in the "tocheck_compatible512.txt" file

// We load "tocheck_compatible512.txt" list

// We observe that the only possibile basket coming from {* 2/5^^4 *} for the intermediate quotient 
// of order 512 is the empty basket {* *} since 5 does not divide 512.

//FinRes_512:=[**];

// for x in tocheck_compatible512 do 
//  for bas in FinIntBasket({* 2/5^^4 *}) do 
//    Append(~FinRes_512, [*bas, x[2], x[3]*]);
//  end for;
// end for;


// #FinRes_512;
// 49070


ExSurf:=ExistingSurfaces(tocheck_compatible512);
#ExSurf;
32 

// From Prop. 3.3 and Remark 3.10 (1) of our paper, the bigger group of order 2560 is a semidirect product of a subgroup of order 512 by an automorphism of that subgroup of order 5. Thus, first of all we have to select only those groups of order 512 that admit an automorphism of order 5. A first easy check is that the order of the automorphism group has to be divisible by 5. 

for x in ExSurf do 
  if IsDivisibleBy(#AutomorphismGroup(SmallGroup(x[3][1],x[3][2])), 5) then 
     x; 
  end if;
end for; 

[*
    {* *},
    {*
        {* 2^^5 *}^^2
    *},
    <512, 66191>
*]

// Now we should construct the bigger group off order 2560 as a semidirect product of H:=SmallGroup(512, 66191) by an automorphism of H of order 5. Let us count the number of automorphisms of H; 


H:=SmallGroup(512, 66191);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord5:=[phi: phi in P| Order(phi) eq 5]; {*Order(phi): phi in P*};

{* 1, 2^^1084415, 3^^327680, 4^^27161600, 5^^1572864, 6^^23265280, 8^^30474240, 
10^^23592960, 12^^18350080 *}

// Hence there 1572864 automorphisms of H of order 5. It is very expensive to construct for each of these automorphisms a semidirect product of H and to look for those admitting a spherical system of generators of signature {* 2, 5, 5 *}. For this reason, we simply observe that all of these automorphisms are conjugated to each other, and so, as a standard result of group theory, they define isomorphic semidirect products:

for i in [1..#ConjugacyClasses(P)] do 
   if ConjugacyClasses(P)[i][1] eq 5 then 
      ConjugacyClasses(P)[i]; 
   end if; 
end for;

<5, 1572864, (1, 96, 160, 57, 89)(2, 140, 94, 43, 61)(3, 53, 139, 131, 17)(4, 28, 145, 152, 45)(5, 112, 110, 23, 148)(6, 144, 34, 44, 55)(7, 8, 54, 70, 102)(9, 46, 77, 63, 83)(10, 116, 37, 48, 138)(11, 
    120, 147, 73, 155)(12, 14, 91, 106, 33)(13, 20, 51, 30, 38)(15, 124, 99, 76, 36)(16, 92, 150, 97, 159)(18, 114, 59, 121, 21)(19, 24, 115, 32, 100)(22, 143, 69, 25, 47)(26, 52, 117, 108, 85)(27, 118, 
    50, 41, 93)(29, 95, 71, 133, 127)(31, 136, 78, 134, 98)(35, 86, 75, 137, 74)(39, 65, 132, 82, 72)(40, 142, 113, 153, 149)(42, 58, 151, 56, 90)(49, 107, 158, 141, 122)(60, 79, 109, 135, 156)(62, 67, 
    68, 84, 101)(64, 88, 125, 126, 130)(66, 123, 157, 119, 105)(80, 81, 154, 87, 129)(103, 104, 128, 111, 146)>

// Hence we only have one semidirect product of the group H by an automorphism of H of order 5, up isomorphism. Let us define it: 

phi:=P! (1, 96, 160, 57, 89)(2, 140, 94, 43, 61)(3, 53, 139, 131, 17)(4, 28, 145, 152, 45)(5, 112, 110, 23, 148)(6, 144, 34, 44, 55)(7, 8, 54, 70, 102)(9, 46, 77, 63, 83)(10, 116, 37, 48, 138)(11, 
    120, 147, 73, 155)(12, 14, 91, 106, 33)(13, 20, 51, 30, 38)(15, 124, 99, 76, 36)(16, 92, 150, 97, 159)(18, 114, 59, 121, 21)(19, 24, 115, 32, 100)(22, 143, 69, 25, 47)(26, 52, 117, 108, 85)(27, 118, 
    50, 41, 93)(29, 95, 71, 133, 127)(31, 136, 78, 134, 98)(35, 86, 75, 137, 74)(39, 65, 132, 82, 72)(40, 142, 113, 153, 149)(42, 58, 151, 56, 90)(49, 107, 158, 141, 122)(60, 79, 109, 135, 156)(62, 67, 
    68, 84, 101)(64, 88, 125, 126, 130)(66, 123, 157, 119, 105)(80, 81, 154, 87, 129)(103, 104, 128, 111, 146);

phi @@ r;
Automorphism of GrpPC : H which maps:
    H.1 |--> H.2 * H.6 * H.8 * H.9
    H.2 |--> H.1 * H.3 * H.4 * H.6 * H.7 * H.8
    H.3 |--> H.2 * H.4 * H.6 * H.9
    H.4 |--> H.3 * H.4
    H.5 |--> H.5 * H.7 * H.9
    H.6 |--> H.9
    H.7 |--> H.7 * H.8 * H.9
    H.8 |--> H.7 * H.9
    H.9 |--> H.6 * H.8

K:=SmallGroup(5,1);
t:=hom<K -> AutH| <K.1, phi @@ r>>;
G:=SemidirectProduct(H,K,t);

// Now we check if G admits a spherical system of generators of signature {* 2, 5, 5 *}: 

if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <5,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
            ExSphSystem_givenG(G,{* 2, 5, 5 *});                       
end if;
<5, 1>
true

// Now it only remains to check if G admits a pair of spherical systems of generators of signature {* 2, 5, 5 *} compatible with the basket of singularities {* 2/5^^4 *}: 

ExistingSurfaces_triple_givenG([*{* 2/5^^4 *},{*{* 2, 5, 5 *}^^2*},G*]);
false

// Hence we can finally exclude the case [* {* 2/5^^4 *}, {*{*2, 5, 5 *}^^2*}, 2560 *] of Result. 


//

[* x: x in Result_2| x[3] eq 1264*];
[* [*
    {* 5/12, 1/2^^2, 7/12 *},
    {*
        {* 4^^3 *}^^2
    *},
    1264
*] *]

// This comes from a group of order 3792 in Result:

[*x : x in Result | x[3] in {1264*i: i in [1..10]}*];    
[* [*
    {* 5/12, 1/2^^2, 7/12 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    3792
*] *]

Final:=[**];
tocheck_compatible3792:=[**];

K:=SmallGroup(3,1);

for i in [1..NumberOfSmallGroups(1264)] do 
 for x in [* y : y in Result_2|y[3] eq 1264*] do 

H:=SmallGroup(x[3],i);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord3:={phi: phi in P| Order(phi) eq 3}; {*Order(phi): phi in P*};
  for phi in ord3 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <3,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{* 3, 3, 4 *}) then 
             Append(~tocheck_compatible3792,[*x[1],{*{* 3, 3, 4 *}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;
end for;

tocheck_compatible3792;
[* *]

//

[* x: x in Result_2| x[3] eq 1416*];
[* [*
    {* 1/8, 3/8, 1/2^^3 *},
    {*
        {* 4^^3 *}^^2
    *},
    1416
*] *]

[*x : x in Result | x[3] in {1416*i: i in [1..10]}*];
[* [*
    {* 1/8, 3/8, 1/2^^3 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    4248
*] *]

Final:=[**];
tocheck_compatible4248:=[**];

K:=SmallGroup(3,1);

for i in [1..NumberOfSmallGroups(1416)] do 
 for x in [* y : y in Result_2|y[3] eq 1416*] do 

H:=SmallGroup(x[3],i);
  AutH:=AutomorphismGroup(H); 
  r, P:=PermutationRepresentation(AutH);
  ord3:={phi: phi in P| Order(phi) eq 3}; {*Order(phi): phi in P*};
  for phi in ord3 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <3,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{* 3, 3, 4 *}) then 
             Append(~tocheck_compatible4248,[*x[1],{*{* 3, 3, 4 *}^^2*},G*]); 
           end if; 
    end if;
    
  end for;
end for;
end for;

tocheck_compatible4248;
[* *]


// In this way we have excluded all the cases of Result list. Now we have to exclude the last 14 cases stored in NotSatisfyProp33

NotSatisfyProp33;
[* [*
    {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2112
*], [*
    {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2112
*], [*
    {* 1/4^^4, 1/2^^2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2016
*], [*
    {* 1/4^^4, 1/2^^2 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2016
*], [*
    {* 1/6, 2/9, 5/18 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2208
*], [*
    {* 1/8^^2, 1/4, 1/2 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2448
*], [*
    {* 1/8^^2, 1/4, 1/2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2448
*], [*
    {* 1/10, 1/5^^2, 1/2 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2448
*], [*
    {* 1/10, 1/5^^2, 1/2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2448
*], [*
    {* 1/12, 5/12, 1/2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2400
*], [*
    {* 1/6, 1/3^^4, 1/2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2016
*], [*
    {* 1/6, 1/3^^4, 1/2 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2016
*], [*
    {* 1/12, 1/4, 1/3^^2 *},
    {*
        {* 2, 3, 12 *}^^2
    *},
    2448
*], [*
    {* 1/12, 1/4, 1/3^^2 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    2448
*] *]

time how_to_excludePG(NotSatisfyProp33);
[* *]
Time: 5.350

// The abelianization of the orbifold group of signature {* 2, 3, 12 *} is C6, hence the abelianization of G may be at most either C2, C3, or C6. If the abelianization if C6, then it there exists a normal subgroup of G with index 2, the inverse image of a index 2 subgroup of C6 by the abelianization map of G. 

L:=[**];
for x in NotSatisfyProp33 do 
if {*2,3,12*} in x[2] then 
for y in List_Intermediate_Sign_from_a_triple(x,2) do 
Append(~L, y);
end for;
for y in List_Intermediate_Sign_from_a_triple(x,3) do 
Append(~L, y);
end for;
end if;
end for;


time Res,Res_Ab:=how_to_exclude(L);
Time: 397.750

#Res;
31

IntBasket:=function(a, j)
  IntB:=[];
  B:={k/a : k in [1..a-1]};
  for i in [0..j] do 
    Append(~IntB, Multisets(B, i));
  end for;
  Fin:={};
  for i in [1..#IntB] do 
    for s in IntB[i] do 
      Include(~Fin, s);
    end for;
  end for;
  return Fin;
end function;

FinIntBasket:=function(basket)
  Final:=[**];

  t:={* Denominator(r): r in basket*};
  Seq:=[[a,#[ x : x in t | x eq a]]: a in MultisetToSet(t)];
  A:=[];
  for s in Seq do 
     Append(~A, IntBasket(s[1],s[2]));
  end for;  
  for x in CartesianProduct(A) do  
   int_bas:={**};
   for l in x do 
    for y in l do 
      Include(~int_bas, y); 
    end for;
   end for;
   Append(~Final, int_bas);
  end for; 
  return {x : x in Final};
end function;

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExistingSurfaces(FinRes);
[* *]
Time: 9023.410

// It only remains to exclude those triples of NotSatisfyProp33 having signature {*2,4,6*}, whose orbifold group has abelianization C2^2. Hence G has abelianization either C2 or C2^2. However 

L:=[**];
for x in NotSatisfyProp33 do 
if {*2,4,6*} in x[2] then 
for y in List_Intermediate_Sign_from_a_triple(x,2) do 
Append(~L, y);
end for;
end if;
end for;

time Res,Res_Ab:=how_to_exclude(L);
Time: 3005.240

#Res;
15

FinRes:=[**];

for x in Res do 
  for bas in FinIntBasket(x[1]) do 
    Append(~FinRes, [*bas, x[2], x[3]*]);
  end for;
end for;

time ExistingSurfaces(FinRes);
[* *]
Time: 288.840

// We have excluded all the cases stored in the secondary output of ListGroups(24,4);