// We load the secondary output of ListGroups for (chi,Ksquare)=(1,0)

// We observe that 

 {*SecOutput[i][3]: i in [1..#SecOutput]*};

{* 480^^46, 640, 768^^5, 960^^12, 1152^^5, 1536, 1920, 2160^^4, 2184, 2400^^3, 
2520^^10, 2592^^3, 2688^^2, 2880^^3, 5040^^3 *}

// No one of the groups of the list can be perfect: 

time how_to_excludePG(SecOutput);
[* *]
Time: 11.930

// Let us exclude those triples having group order {480,640,960,1152,1920};

time Result:=how_to_exclude(SecOutput: Interested_orders:={480,640,960,1152,1920}); 

Result;
[* [*
    {* 1/6, 2/9, 5/18 *},
    {*
        {* 2, 4, 6 *}^^2
    *},
    <480, 951>
*] *]

ExistingSurfaces(Result);
[* *]


time Result:=how_to_exclude(SecOutput: Interested_orders:={768});
Time: 7606.430

Result;                                                          
[* [*
    {* 1/6, 1/2^^2, 5/6 *},
    {*
        {* 2, 3, 8 *}^^2
    *},
    <768, 1085341>
*] *]

ExistingSurfaces(Result);
[* *]

// We now exclude the unique case of group order 1536. This case is the following:

SecOutput[2];
[*
    {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 3, 8 *}^^2
    *},
    1536
*]

// However, from Proposition 3.3 of "The classification of minimal product-quotient surfaces with pg=0" by Bauer-Pignatelli, there is only one group of order 1536 admitting an appropriate spherical system of generators of signature {2,3,8}. This group is <1536, 408544637>. Let us consider 

Result:=[*[*
 {* 1/6^^2, 1/2^^2, 2/3 *},
    {*
        {* 2, 3, 8 *}^^2
    *},
    <1536, 408544637>
*]*];

ExistingSurfaces(Result);
[* *]

// In this way we have excluded all groups of SecOutput less or equal than 2000. 


////////////////////////////////////////////////////////////

List:=[*x : x in SecOutput | x[3] gt 2000*];

Result, NotSatisfyProp41, PerfectGroups:=List_Intermediate_Sign(List);

 #Result;
11
> #NotSatisfyProp41;
0
> #PerfectGroups;
18

// Since we have already excluded that no one of the groups of SecOutput is not perfect, then we can automatically exclude the triples stored in PerfectGroups;

// Hence it remains to exclude the triples stored in Result;

Res,ResAb:=how_to_exclude(Result);

Res;
[* [*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    <1080, 260>
*], [*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    <1080, 487>
*] *]

// These came from the following triple of List 

[*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 2, 3, 8 *}^^2
    *},
    2160
*]

// Hence <1080, 260> or <1080, 487> should be a normal subgroup H of index 2 of a group  G of order 2160.

// If [g_1,g_2,g_3] is a ssg of signature [2,3,8], then g_1 has order two and from Proposition 4.2 is not contained in H. Furthermore, by Remark 4.9(1) we have G is a semidrect product of H and Z_2 by an automorphism phi of order two. 

// <1080, 260> 

x:=[*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    <1080, 260>
*];
Final:=[**];
tocheck_compatible2160:=[**];


K:=SmallGroup(2,1);
H:=SmallGroup(1080,260);
  AutH:=AutomorphismGroup(H);
  r, P:=PermutationRepresentation(AutH);
  ord2:={phi: phi in P| Order(phi) eq 2};
  for phi in ord2 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <2,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*2,3,8*}) then 
             Append(~tocheck_compatible2160,[*{* 1/8, 1/4^^2, 3/8 *},{*{*2,3,8*}^^2*},G*]); 
           end if; 
    end if;
    
  end for;

#tocheck_compatible2160;
36

ExSurf2160:=[**];

for x in tocheck_compatible2160 do 
       IdentifyGroup(quo<x[3]|DerivedGroup(x[3])>); // DEBUG
       if ExistingSurfaces_triple_givenG(x) then  
            Append(~ExSurf2160, x);
          end if; 
end for;

ExSurf2160;
[* *]

// <1080, 487> 

x:=[*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 3^^2, 4 *}^^2
    *},
    <1080, 487>
*];
Final:=[**];
tocheck_compatible2160:=[**];


K:=SmallGroup(2,1);
H:=SmallGroup(1080,487);
  AutH:=AutomorphismGroup(H);
  r, P:=PermutationRepresentation(AutH);
  ord2:={phi: phi in P| Order(phi) eq 2};
  for phi in ord2 do 
    t:=hom<K -> AutH| <K.1, phi @@ r>>;
    G:=SemidirectProduct(H,K,t);
    Append(~Final, [* x, phi, IdentifyGroup(quo<G|DerivedGroup(G)>)*]);
    if IdentifyGroup(quo<G|DerivedGroup(G)>) eq <2,1> then
       IdentifyGroup(quo<G|DerivedGroup(G)>);
           if  ExSphSystem_givenG(G,{*2,3,8*}) then 
             Append(~tocheck_compatible2160,[*{* 1/8, 1/4^^2, 3/8 *},{*{*2,3,8*}^^2*},G*]); 
           end if; 
    end if;
    
  end for;

#tocheck_compatible2160;
36

ExSurf2160:=[**];

for x in tocheck_compatible2160 do 
       IdentifyGroup(quo<x[3]|DerivedGroup(x[3])>); // DEBUG
       if ExistingSurfaces_triple_givenG(x) then  
            Append(~ExSurf2160, x);
          end if; 
end for;

ExSurf2160;
[* *]

// This last step excludes also the last case 

[*
    {* 1/8, 1/4^^2, 3/8 *},
    {*
        {* 2, 3, 8 *}^^2
    *},
    2160
*]