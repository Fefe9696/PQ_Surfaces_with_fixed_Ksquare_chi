////////////////////////////////////////////////////////////////////////////////////////////////
//These are the tools to compute the invariants of a Product-Quotient surface and the basket of singularities of its quotient model. 
////////////////////////////////////////////////////////////////////////////////////////////////


// First we define mu of the basket. Since it only depends on 
// the denominators we make it as a function on a multiset of 
// positive integers: we will run it on the multiset of the
// denominators of the basket.

mu:=function(multisetofint)
  w:=0; 
   for i in multisetofint do w+:=(1-1/i); 
   end for;   
  return w;
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

//This script computes the genus of the intermediate curve C/H where H is a subgroup of G.


GenusOfIntermediateQuotientCurve:=function(group,gens,subgroup)
  OrdG:=Order(group);
// first I reconstruct the type from the system of generators
  type:={* *}; 
   for g in gens do 
     Include(~type,Order(g)); 
   end for;
// then I compute twogmin2, twice the genus of the 
// G-cover minus 1, 2g(C)-2
  twogmin2:=(mu(type)-2)*Order(group);
// Now I run a loop to add "(o(Stab_H(p))-1" to 2gmin2 
// for all p in C
   for g in gens do 
// To each generator g there are |G|/|g| points in c 
// stabilized by a cyclic group generated by a conjugated of g
// Let's then find the conjugacy class of g
// and set n for its cardinality
     ConjugacyClassOfg:={ }; 
      for p in group do 
        Include(~ConjugacyClassOfg,g^p); //SI PUO MIGLIORARE CON Class(group, g);
      end for;
        n:=#ConjugacyClassOfg; Ordg:=Order(g);
// Each element in ConjugacyClassOfg generates the 
// G-stabilizer of |G|/(n*|g|) points,
// so for each of them I subtract |G|/(n*|g|) times the order 
// of the corresponding H-stabilizer
   for h in ConjugacyClassOfg do
   for d in Divisors(Ordg) do
   if h^d in subgroup then 
     twogmin2+:=-((Ordg/d-1)*OrdG)/(n*Ordg); break d;
   end if; end for; end for; end for;
// Then by Hurwitz formula I can return the genus of C/H
  return (1+twogmin2/(2*Order(subgroup)));
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

// Now we focus on product-quotient surfaces.
// First we plan to study the basket of C1xC2/H
// We compute the basket of C1xC2/G, computing, 
// for a pair of elements of G, one for each set of spherical 
// generators, all the singular points of C1xC2/G lying over 
// the corresponding point of (C1/G)x(C2/G)
// We write then an adapted version of it, looking instead 
// for the singular points of C1xC2/H lying over the 
// corresponding point of (C1/G)x(C2/G)

// So the input is the "group" G, 
// the two elements are "gen1" and "gen2"

BasketByAPairOfGensAndASubgroup:=function(group,gen1,
                                          gen2,subgroup)
// First we insert a multiset preimageofbasket
  Preimageofbasket:={* *}; 
// Then we copy word-by-word BasketByAPairOfGens
  basket:={* *}; 
  RC:={ }; delta:=GCD(Order(gen1),Order(gen2));
  alpha1:=IntegerRing()!(Order(gen1)/delta);
  alpha2:=IntegerRing()!(Order(gen2)/delta);
  RC2,f2:=RightTransversal(group,sub<group | gen2 >);
   for g2 in RC2 do test:=true;
      for g in sub<group| gen1 > do
      if f2(g2*g) in RC then test:=false; break g;
      end if; end for;
   if test then Include(~RC, g2);
   end if; end for;
   for g in RC do 
   for d1 in [1..delta-1] do
   for d2 in [1..delta-1] do
   if (gen1^(d1*alpha1)) eq (gen2^(d2*alpha2))^g then
// Here we modify the script. 
// gen2^(d2*alpha2) is a generator of the G-stabilizer of one
// of the points of C1xC2 lying on a singular point of C1xC2/G 
// of type d2/delta.
// First we write the whole conjugacy class of 
// gen2^(d2*alpha2), getting generators of the stabilizers of 
// all points of C1xC2 lying on that singular point of C1xC2/G
     ConjugacyClassOfg:={ }; 
      for p in group do 
       Include(~ConjugacyClassOfg,(gen2^(d2*alpha2))^p);
      end for;
// They are c of them, each generating the stabilizer of the 
// same number of points of C1xC2 lying on that singular point 
// of C1xC2/G
     c:=#ConjugacyClassOfg;
// That singular point of type d2/delta of C1xC2/G
// (say with reduced form p/q, as d2 and delta may be not 
// relatively prime) has preimage given by |group|/q points, 
// all with cyclic stabilizer generated by one the c different 
// elements of ConjugacyClassOfg, each generating the 
// stabilizer of |group|/cq  points.
// Set k(h) for the cardinality of the intersection of our 
// subgroup with the cyclic subgroup <h> generated by one h in 
// ConjugacyClassOfg. 
// Then each point stabilized by <h> for the action of the 
// group has stabilizer of order (q/k(h)) for the action of 
// the subgroup, and maps, on the quotient C1xC2/subgroup, 
// to a singular point of type {pk(h)/q} where {} stands for 
// "fractional part". 
// So we create a multiset Preimageofbasket, and for each such 
// h in ConjugacyClasses(G)
// we add to the multiset  |group|/cq times {pk(h)/q}.
      for h in ConjugacyClassOfg do  
      for k in [1..Order(h)-1] do
      if h^k in subgroup then 
        Include(~Preimageofbasket, (FractionalPart(k*d2/delta))^^IntegerRing()!(#group/(c*Denominator(d2/delta)))); 
        break k;
      end if; end for; end for;
     break d1;
   end if; end for; end for; end for;
// Running it on all h in ConjugacyClasses(G) we will get then 
// a multiset of rational numbers corresponding to the basket 
// of C1xC2/H in the sense that each a/b in the basket will 
// appear as many times as  the cardinality of its fibre, so 
// |subgroup)/b, and therefore we have to divide 
// each exponent by that.
  Rats:=MultisetToSet(Preimageofbasket); 
   for rat in Rats do
     exp:=IntegerRing()!(Multiplicity(Preimageofbasket,rat)*Denominator(rat)/#subgroup);
     Include(~basket, rat^^exp );
   end for;
  return basket;
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

// Now we produce the whole basket of the quotient by a 
// subgroup

BasketOfIntermediateQuotientSurface:=function(gens1,gens2,
                                           group,subgroup)
  Basket:={* *};
   for gen1 in gens1 do
   for gen2 in gens2 do 
     Basket:=Basket join
    BasketByAPairOfGensAndASubgroup(group,gen1,gen2,subgroup);
   end for; end for;
  return Basket;
end function;

////////////////////////////////////////////////////////////////////////////////////////////////


// Now we need a script for computing all baskets related to a 
// certain multiplicity. First we need to compute the 
// continued fraction of a rational  number and viceversa the 
// rational number of a continued fraction: these are 
// respectively the programs 
// ContFrac: for 0<s<1, the continued fraction of 1/s, 
// RatNum: computes 1/s from the continued fraction.

ContFrac:=function(s)
  CF:=[ ]; r:=1/s;
   while not IsIntegral(r) do
     Append(~CF, Ceiling(r)); r:=1/(Ceiling(r)-r);
   end while;
  return Append(CF, r);
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

// We compute Gamma of a rational and then (GammaBas) of a 
// basket

DuaL:=func<t|
      Modinv(Numerator(t),Denominator(t))/Denominator(t)>;

Gamma:=func<t|(&+(ContFrac(t))-3*#(ContFrac(t))+t+DuaL(t))/6>;

GammaBas:=function(bas)
   g:=0; 
    for rat in bas do g+:=Gamma(rat); 
    end for; 
   return g;
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

//Finally, this script computes the Basket of Singularities of (C_1xC_2)/G and the Invariants K^2, chi, pg, q of its product-quotient surface. 

BasketAndInvariants:=function(sequence , group)
     prodgmin1:=1;
     Signature1:=[Order(sequence[1][ i ]) : i in [1..#sequence[1] ] ];
     Signature2:=[Order(sequence[2][ i ]) : i in [1..#sequence[2] ] ];
     pairoftypes :=[Signature1,Signature2];
   for type in pairoftypes do 
     gmin1:=((mu(type)-2)*Order(group)/2);
     prodgmin1:= prodgmin1 * gmin1;
   end for; 

  
  
     BasketAndInvariants:=[* *]; 
     subgroup:=group;
// First the irregularity
     q:=GenusOfIntermediateQuotientCurve(group, sequence[1],subgroup)  +GenusOfIntermediateQuotientCurve(group,sequence[2],subgroup);
// Then the basket
        IntermediateBasket:=
          BasketOfIntermediateQuotientSurface(sequence[1], 
                            sequence[2],group,subgroup);
        Den:={* *}; l:=0;
         for s in IntermediateBasket do 
           l+:=#ContFrac(s);
           Include(~Den,Denominator(s)); 
         end for;
        mue:=mu(Den);
        gamma:=GammaBas(IntermediateBasket);
//Finally the invariants
        Ksquare:=2*mue-6*gamma-l+8*prodgmin1/Order(subgroup); 
        chi:=prodgmin1/Order(subgroup)+(mue-2*gamma)/4;
        pg:=chi+q-1;

        
  return   [*IntermediateBasket, Ksquare, pg, q*];
end function;